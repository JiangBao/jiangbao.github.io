[{"categories":["生活"],"content":" Double happiness ","date":"2021-02-09","objectID":"/2021-02-09/:0:0","tags":["生活"],"title":"2021-02-09","uri":"/2021-02-09/"},{"categories":["技术"],"content":"1. new 思路 js的new运算符用于创建对象的实例，使用new的时候主要有以下操作： 创建空对象{} 链接该对象(设置该对象的constructor)到另一个对象 将步骤1新创建的对象作为this的上下文 如果该函数没有返回对象，则返回this show me the code function customizeNew(Fn, ...args) { // 创建空对象并链接到原型 let obj = Object.create(Fn.prototype); // 绑定this let res = Fn.apply(obj, args); return res instanceof Object ? res : obj; } ","date":"2021-01-02","objectID":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/:1:0","tags":["技术","JavaScript"],"title":"手写前端常用功能","uri":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"categories":["技术"],"content":"2. 手写Promise 思路 Promise主要解决传统异步编程中“回调地狱”导致代码阅读性和维护性差的问题，使用链式风格替代传统的嵌套回调风格，是更优雅的异步编程解决方案。 根据「Promise/A+规范」，promise有三个状态：pending(待定)、fulfilled(已兑现)、rejected(已拒绝)，需要实现的基础功能包括： new Promise()参数需要一个处理器函数executor() 处理器函数的参数为resolve和reject，成功调用resolve函数，失败调用reject函数 默认状态为pending，只能从peding到fulfilled或rejected，且状态确认后不可再改变 包含then方法，接收onFulfilled和onRejected参数，成功执行onFulfilled，失败执行onRejected show me the code const STATUS = { PENDING: 'PENDING', FULFILLED: 'FULFILLED', REJECTED: 'REJECTED', }; class MyPromise { constructor(executor) { this.status = STATUS.PENDING; //默认状态pending this.value = undefined; //fulfilled状态时的值 this.error = undefined; //rejected状态时的错误原因 this.onResolvedCallbacks = []; //存放成功的回调 this.onRejectedCallbacks = []; //存放失败的回调 this._resolve = this._resolve.bind(this); this._reject = this._reject.bind(this); try { executor(this._resolve, this._reject); } catch (e) { this._reject(e); } } _resolve(value) { setTimeout(() =\u003e { this.value = value; this.status = STATUS.FULFILLED; this.onResolvedCallbacks.forEach(fn =\u003e fn(value)); }) } _reject(error) { setTimeout(() =\u003e { this.error = error; this.status = STATUS.REJECTED; this.onRejectedCallbacks.forEach(fn =\u003e fn(error)); }) } then(onFulfilled, onRejected) { return new MyPromise((resolve, reject) =\u003e { this.onResolvedCallbacks.push((value) =\u003e { try { const res = onFulfilled(value); if (res instanceof MyPromise) { res.then(resolve, reject); } else { resolve(res); } } catch (e) { reject(e); } }); this.onRejectedCallbacks.push((value) =\u003e { try { const res = onRejected(value); if (res instanceof MyPromise) { res.then(resolve, reject); } else { reject(res); } } catch (e) { reject(e); } }) }) } } ","date":"2021-01-02","objectID":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/:2:0","tags":["技术","JavaScript"],"title":"手写前端常用功能","uri":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"categories":["技术"],"content":"3. 节流throttle 思路 限制目标函数使用频率，规定的单位时间内只能触发一次，如果此时间内多次触发，只有一次生效 show me the code function throttle(func, ms=1000) { let canRun = true; return function(...args) { if (!canRun) return; canRun = false; setTimeout(()=\u003e { func.apply(this, args); canRun = true; }, ms); } } ","date":"2021-01-02","objectID":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/:3:0","tags":["技术","JavaScript"],"title":"手写前端常用功能","uri":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"categories":["技术"],"content":"4. 防抖debounce 思路 事件触发n秒后再执行回调，如果这n秒内又被触发，则重新计时 show me the code function debounce(func, ms=1000) { let timer; return function(...args) { if (timer) { clearTimeout(timer); } timer = setTimeout(() =\u003e { func.apply(this, args); }, ms); } } ","date":"2021-01-02","objectID":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/:4:0","tags":["技术","JavaScript"],"title":"手写前端常用功能","uri":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"categories":["技术"],"content":"5. bind 思路 改变函数this指向，并返回一个待执行方法，执行时可继续传入参数，即fn.bind(ctx, arg1)(arg2) == fn.cal(ctx, arg1, arg2) show me the code Function.prototype.myBind = function() { if (typeof this !== 'function') { throw 'caller must be a function' } let self = this; let [ctx, ...args] = [...arguments]; let fn = function() { const newArgs = [...args, ...arguments] if (this instanceof fn) { // new调用，绑定this为实例对象 self.apply(this, newArgs) } else { // 普通调用 self.apply(ctx, newArgs) } } fn.prototype = Object.create(self.prototype); return fn; } ","date":"2021-01-02","objectID":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/:5:0","tags":["技术","JavaScript"],"title":"手写前端常用功能","uri":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"categories":["技术"],"content":"6. call 思路 将this指向调用者，在调用者(context)上直接调用方法，触发this的绑定 show me the code Function.prototype.myCall = function() { if (typeof this !== 'function') { throw 'caller must be function' } const [ctx, ...args] = [...arguments] // 可以通过Symbol设置key，防止覆盖原有属性 ctx._fn = this const res = ctx._fn(args) delete ctx['_fn'] return res } ","date":"2021-01-02","objectID":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/:6:0","tags":["技术","JavaScript"],"title":"手写前端常用功能","uri":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"categories":["技术"],"content":"7. apply 思路 同call show me the code Function.prototype.myApply = function() { if (typeof this !== 'function') { throw 'caller must be function' } let res const [ctx, args, ...others] = [...arguments] ctx._fn = this if (args) { res = ctx._fn(...args) } else { res = ctx._fn() } delete ctx._fn return res } ","date":"2021-01-02","objectID":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/:7:0","tags":["技术","JavaScript"],"title":"手写前端常用功能","uri":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"categories":["技术"],"content":"8. 深拷贝 思路 核心思路是在浅拷贝的基础上，对子项为对象类型的进行递归；对于循环引用的问题可以使用WeakMap缓存比较来解决 show me the code function cloneDeep(obj, cache = new WeakMap()) { if (!obj instanceof Object) return obj if (obj instanceof Date) return new Date(obj) if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags) // 循环引用比较 if (cache.get(obj)) return cache.get(obj) // 支持函数 if (obj instanceof Function) { return function() { obj.apply(this, arguments) } } const res = Array.isArray(obj) ? [] : {} cache.set(obj, res) Object.keys(obj).forEach(key =\u003e { if (obj[key] instanceof Object) { res[key] = cloneDeep(obj[key], cache) } else { res[key] = obj[key] } }) return res } Promise|MDN juejin|iboying github|sisterAn ","date":"2021-01-02","objectID":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/:8:0","tags":["技术","JavaScript"],"title":"手写前端常用功能","uri":"/%E6%89%8B%E5%86%99%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD/"},{"categories":["生活"],"content":"我的2020年总结","date":"2020-12-31","objectID":"/%E6%88%91%E7%9A%842020%E5%B9%B4/","tags":["生活"],"title":"我的2020年","uri":"/%E6%88%91%E7%9A%842020%E5%B9%B4/"},{"categories":["生活"],"content":" 新发芽的薄荷 2020年真是令人难忘的一年，年初开始的一场新冠疫情让全国人民都陷入了恐慌😷，恰逢春节时期，大家都只能窝在家中过了这个春节。继而随着疫情在全球的扩散，感染人数不断上升，全球似乎被按下暂停键，这一年整个世界都笼罩在新冠病毒的阴影下缓慢前进。 ","date":"2020-12-31","objectID":"/%E6%88%91%E7%9A%842020%E5%B9%B4/:0:0","tags":["生活"],"title":"我的2020年","uri":"/%E6%88%91%E7%9A%842020%E5%B9%B4/"},{"categories":["生活"],"content":"工作 💻 困难不断的创业过程，公司去年发展不错，去年底经历了一波人员和业务线的扩张，但突如其来的疫情导致业务收缩，年初经历了一次大的人员变动，随后进行了3个半月的全员居家办公，波折不断，但整体业务与盈利还算平稳。 今年主要业务还是几个棋牌游戏的迭代，整体收益稳定，但未迎来大的增长。做了两个工具类小程序；尝试了游戏出海，但商务上遇到的问题比较多，出海不是很顺利。 技术上，今年主要在整理各端框架，避免之前技术栈混乱，人员变动导致的历史包袱过重的问题。形成前、后端、后台整体JS/TS的技术栈，后端：egg+pomelo，前端：cocos creator，后台：Ant Design Pro，小程序：uni-app。对老项目做了大量的重构，虽然工作量比较大，但规范化带来的收益还是值得的。 做了一些技术团队规范化的工作，整个团队经过了去年从无到有的过程，尽量不再频繁加班，有序排好需求，规范化接口文档，避免浪费不必要的对接时间；完善自动化测试、部署流程(jenkins\u0026github action)。 合伙人商业决策问题、同事工作效率问题、利益分配问题等等，公司这一年走得很艰难，11月，决定离开团队了。两年左右的创业经历，做产品，找渠道，管理小的技术团队，疯狂加班迭代，熬夜肉身运维….学习到了很多，要做成一个产品，养活一个团队，涉及太多复杂的问题，站在技术人员的角度，面对这些问题往往会有无力感，明年重新回归技术，沉淀自己，感谢这段经历。 ","date":"2020-12-31","objectID":"/%E6%88%91%E7%9A%842020%E5%B9%B4/:0:1","tags":["生活"],"title":"我的2020年","uri":"/%E6%88%91%E7%9A%842020%E5%B9%B4/"},{"categories":["生活"],"content":"生活 👨‍👩‍👧 因为新冠疫情的原因，一大家人窝在家一起度过了整个春节，从小到大最难忘最特别的一个春节假期了。 还窝在家的时候，1月26日，科比意外坠机去世，突如其来的新闻，学生时代最爱的偏执狂球星，以这种方式告别了，本来还期待着他退役后会带来怎样的传奇。 复工后和老婆一起回到杭州继续做打工人，女儿留在她爷爷奶奶身边成了留守儿童，今年每个有空的周末不再折腾，直奔回家带娃。我要努力安定下来，不再漂泊，更好地为她遮风挡雨。 年中老丈人突发脑梗，走路和语言能力都受损，后期并发了糖尿病，经历了漫长的恢复期，目前有所进步。永远不知道明天和意外谁会先来，一场疾病可能就彻底改变生活方式了。 高考因为疫情延期了，7月7日，高考延期的第一天，家乡突遭洪水，淹了半个县城，老家因此上了新闻，这场面真是没见过😟 搬了一次家，卖掉了自己的游戏机，显示器，闲置的衣服、鞋子，过更简单的生活。以前屯的一堆纸质书舍不得卖，运回老家，减轻以后搬家的负担，今年尽量保持电子化阅读了，发现微信读书在ipad端使用不错，后半年基本从kindle过渡到ipad端的微信读书。 ","date":"2020-12-31","objectID":"/%E6%88%91%E7%9A%842020%E5%B9%B4/:0:2","tags":["生活"],"title":"我的2020年","uri":"/%E6%88%91%E7%9A%842020%E5%B9%B4/"},{"categories":["生活"],"content":"读的几本书 📖 变量2：推演中国经济基本盘 万古江河 汴京之围 上帝掷骰子吗？ 凤凰项目 运营之光2.0 软技能2软件开发者职业生涯指南 学习JavaScript数据结构与算法 CSS揭秘 CSS世界 Go语言实战 Redis设计与实现 你不知道的JavaScript 2020年过去了，正逢寒潮，户外温度很低，不少人却都格外有仪式感地在跨年迎接新的一年，可能因为这一年对很多人都太难了，大家都希望早点向糟糕的2020年告别。这一年自己感觉的一些不足： 没有养成规律健身的习惯，只在颈椎不舒服那一阵保持了锻炼，后来又放弃了 产出不够，虽然读了几本书，研究了几个框架的源码，工作上也踩了不少坑，但产出还是太少了，需要加强复盘，提高知识转化的能力。立个flag：明年做好一个开源项目。 运气差了点，在杭州生活，房子、车牌都得靠摇号，希望明年能入欧吧🙏 这一年，陪伴女儿的时间比较多，泡泡从会爬，会走路，到会说话，目前已经是个很会闹腾的娃娃了，从孩子身上看到了时间的飞快，努力挣钱，强身健体，为她遮风挡雨，爱别人也是一件幸福的事情。今年离开了两年来一起走来的创业团队，也有过一阵的焦虑，给自己两个月的休息时间，明年再回到工作，佛系的人生就是这么不思进取且快乐。 ","date":"2020-12-31","objectID":"/%E6%88%91%E7%9A%842020%E5%B9%B4/:0:3","tags":["生活"],"title":"我的2020年","uri":"/%E6%88%91%E7%9A%842020%E5%B9%B4/"},{"categories":["技术"],"content":"约球小程序","date":"2020-09-20","objectID":"/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7/","tags":["工具"],"title":"一个小工具","uri":"/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"categories":["技术"],"content":" 一个约球的微信小程序 ","date":"2020-09-20","objectID":"/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7/:0:0","tags":["工具"],"title":"一个小工具","uri":"/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"categories":["生活"],"content":"泡泡","date":"2020-08-30","objectID":"/2020-08-29/","tags":["生活"],"title":"2020-08-29","uri":"/2020-08-29/"},{"categories":["技术"],"content":"最近看到微信小程序支持分享到朋友圈的功能，恰好之前做小程序业务的时候遇到过这样的需求，就来尝试一下这个新功能。 ","date":"2020-08-02","objectID":"/%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88/:0:0","tags":["小程序"],"title":"将小程序分享到朋友圈","uri":"/%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88/"},{"categories":["技术"],"content":"体验 参考官方文档，目前「分享到朋友圈」为Beta功能： 从基础库2.11.3开始支持 支持平台：Android 不支持「分享给好友」那样的页面内分享，只支持顶部菜单栏「分享到朋友圈」的入口。 另外，为防止滥用此功能，从朋友圈打开的时候并不是直接进入小程序，而是进入一个所谓“小程序单页模式”的页面，页面上交互功能受限，所以更适合内容展示型场景。 ","date":"2020-08-02","objectID":"/%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88/:1:0","tags":["小程序"],"title":"将小程序分享到朋友圈","uri":"/%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88/"},{"categories":["技术"],"content":"如何实现 确保基础库版本在2.11.3以上，此时打开待分享页面顶部菜单栏，能看到「分享到朋友圈」的入口，由于没开启开关，所以此时看到应该是置灰的 打开「分享到朋友圈」菜单开关 在带分享页面onLoad或者onShow生命周期添加以下代码，这也就是官方文档所说的：设置允许“发送给朋友”, 允许“分享到朋友圈” wx.showShareMenu({ withShareTicket: true, menus: ['shareAppMessage', 'shareTimeline'] }); 此时应该可以正常使用「分享到朋友圈」的功能(Android) 分享的默认标题为小程序名称，默认图片为小程序logo 自定义分享参数 类似转发给好友的处理函数onShareAppMessage，提供了分享到朋友圈的自定义处理函数onShareTimeline。按照文档，目前支持title、query、imageUrl三个自定义参数。添加代码： onShareTimeline() { return { title: '这是一个自定义的标题！', imageUrl: 'https://image.url' } } 可以看到自定义分享的效果： ","date":"2020-08-02","objectID":"/%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88/:2:0","tags":["小程序"],"title":"将小程序分享到朋友圈","uri":"/%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88/"},{"categories":["技术"],"content":"遇到的问题 由于测试的时候使用的是uni-app构建的项目，导致自定义分享标题、图片的功能不生效，还是使用默认的分享字段，然后又使用微信小程序原生代码创建了项目进行测试，自定义功能是生效的，可能是uni-app版本对新功能的支持问题，果然升级版本之后，已经可以使用自定义功能了。所以使用第三方框架的项目想使用此功能需要注意进行版本升级。 ","date":"2020-08-02","objectID":"/%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88/:3:0","tags":["小程序"],"title":"将小程序分享到朋友圈","uri":"/%E5%B0%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88/"},{"categories":["生活"],"content":"女儿一周岁了~ 爱吃、爱睡的小胖子🎂 ","date":"2020-07-27","objectID":"/2020-07-27/:0:0","tags":["生活"],"title":"2020-07-27🎂","uri":"/2020-07-27/"},{"categories":["技术"],"content":" 插件向第三方开发者提供了webpack引擎中完整的能力。使用阶段式的构建回调，开发者可以引入他们自己的行为到webpack构建流程中。 webpack在编译过程中，会触发一系列Tapable钩子事件，注册相应的钩子，在webpack构建过程中触发钩子执行自定义的任务，就形成了我们自己的plugin。 ","date":"2020-07-25","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89plugin/:0:0","tags":["JavaScript","webpack"],"title":"Webpack 自定义plugin","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89plugin/"},{"categories":["技术"],"content":"背景 插件组成 一个JavaScript命名函数 在插件函数原型上定义一个apply方法 注册一个webpack自身的事件钩子 处理webpack内部实例的特定数据 功能完成后调用webpack提供的回调 执行流程 合并命令行参数与配置文件，解析得到参数对象 参数对象传给webpack得到Compiler对象 执行Compiler的run方法，生成Compilation对象 触发 Compiler 的 make方法分析入口文件，调用 compilation 的 buildModule 方法创建主模块对象 生成入口文件AST，加载依赖模块 模块分析完成后，执行Compilation的seal方法 最后执行Compilation.emitAssets()输出文件 参考这个图示 Compiler与Compilation Compiler：完整的webpack配置环境。这个对象在启动webpack时被一次性创建，并配置好所有可操作的设置，包括options、loader、plugin。当在webpack环境中应用一个插件时，插件可通过compiler对象引用来访问webpack主环境。 Compilation：一次资源版本的构建。开发环境每当检测到问价变化，就会创建新的compilation。 ","date":"2020-07-25","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89plugin/:1:0","tags":["JavaScript","webpack"],"title":"Webpack 自定义plugin","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89plugin/"},{"categories":["技术"],"content":"示例 参考官网，实现一个简单的插件：生成.md文件展示构建生成的文件列表。github仓库 file-list-plugin.js: function FileListPlugin(options={}) { this.filename = options.filename ? options.filename : 'filelist.md'; } FileListPlugin.prototype.apply = function(compiler) { // 注册输出文件之前的钩子 emit compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, cb) =\u003e { // 从compilation.assets获取文件信息 const len = Object.keys(compilation.assets).length; let filelist = `${len}file${len \u003e 1 ? 's': ''}in this build:\\n\\n`; for (let filename in compilation.assets) { filelist += `* ${filename}\\n`; } // 将列表作为新的文件资源，插入到webpack构建 compilation.assets[this.filename] = { source: function() { return filelist; }, size: function() { return filelist.length; } } cb(); }); } module.exports = FileListPlugin; webpack.config.js: module.exports = { //... plugins: [ new FileListPlugin({filename: '_filelist.md'}), ], }; ","date":"2020-07-25","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89plugin/:2:0","tags":["JavaScript","webpack"],"title":"Webpack 自定义plugin","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89plugin/"},{"categories":["技术"],"content":"参考 编写一个插件 揭秘webpack plugin ","date":"2020-07-25","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89plugin/:3:0","tags":["JavaScript","webpack"],"title":"Webpack 自定义plugin","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89plugin/"},{"categories":["技术"],"content":" loader是导出为一个函数的node模块。该函数在loader转换资源的时候调用。给定的函数将调用loader API，并通过this上下文访问。 ","date":"2020-07-23","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/:0:0","tags":["JavaScript","webpack"],"title":"Webpack-自定义loader","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/"},{"categories":["技术"],"content":"背景 webpack自身只能解析JS和JSON文件，无法理解其它类型的的文件模块，当我们需要处理CSS、图片等非JS资源时，需要使用loader将之转换为webpack核心能够理解的形式。loader本质是一个函数，接收待处理的资源模块，输出符合webpack处理规范的的内容。 ","date":"2020-07-23","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/:1:0","tags":["JavaScript","webpack"],"title":"Webpack-自定义loader","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/"},{"categories":["技术"],"content":"loader使用 以简单的css模块处理为例，我们使用style-loader和css-loader这两个loader，类似如下的webpack配置： module.exports = { //... module: { rules: [ test: /\\.css$/, // css-loader: 解析CSS文件，以字符串形式打包到js文件 // style-loader: 把js里的样式代码插入到html use: ['style-loader', 'css-loader'], ] } //... }; loader执行顺序是从后往前，先执行css-loader，再将其执行结果交给style-loader处理。由此可以得到自定义loader时需要遵守的几个基本原则： 单一职责：每个loader只做一个任务，不仅易维护，也可以在更多场景链式调用。 链式传递：资源文件传入第一个loader，后续loader接受上一个loader返回的处理结果。这意味着loader不一定要输出js，只要下一个loader可以处理这个输出，这个loader就可以返回任意类型的模块。 逆向调用：体现在上面的例子就是use配置项从右往左执行，这与js的函数式编程而非管道流相关。 ","date":"2020-07-23","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/:2:0","tags":["JavaScript","webpack"],"title":"Webpack-自定义loader","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/"},{"categories":["技术"],"content":"最简单的自定义loader 编写一个loader，实现功能：替换所有.txt文件中以[name]标记的关键词。gitub仓库 replace-keyword-loader.js: // 利用loader-utils工具包获取传入的参数 const { getOptions } = require('loader-utils'); module.exports = function(source) { const options = getOptions(this); source = source.replace(/\\[name\\]/g, options.keyword); return `export default ${JSON.stringify(source)}`; } webpack.config.js: const path = require('path'); module.exports = { //... module: { rules: [ { test: /\\.txt$/, use: [ { loader: path.resolve('./src/replace-keyword-loader.js'), options: { keyword: 'JiangBao' } } ] } ] }, }; ","date":"2020-07-23","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/:3:0","tags":["JavaScript","webpack"],"title":"Webpack-自定义loader","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/"},{"categories":["技术"],"content":"raw模式 之前的基础示例中，资源文件会默认转化为UTF-8字符串，然后传给loader，但是在一些图片、音频、视频资源下，使用字符串就不合适了，这时候可以接收原文件的Buffer，设置导出raw字段为true即可开启buffer类型的参数。 一个简单的例子：实现最简化的url-loader功能，将图片转为base64编码格式。github仓库 raw-loader.js: const { getOptions } = require('loader-utils'); module.exports = function(source) { const options = getOptions(this); const mimetype = options.mimetype || ''; return `export default ${JSON.stringify(`data:${mimetype};base64,${source.toString('base64')}`)}`; } // 开启buffer类型文件格式 module.exports.raw = true; webpack.config.js: const path = require('path'); module.exports = { //... module: { rules: [ { test: /\\.png$/, use: [ { loader: path.resolve('./src/raw-loader.js'), options: { mimetype: 'image/png' } } ] } ] }, }; ","date":"2020-07-23","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/:4:0","tags":["JavaScript","webpack"],"title":"Webpack-自定义loader","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/"},{"categories":["技术"],"content":"pitch 官网对pitching loader的介绍：loader总是从右到左地被调用，有些情况下，loader只关心request后面的元数据(metadata)，并且忽略前一个loader的结果。在实际（从右到左）执行loader之前，会先从左到右调用loader上的pitch方法。如果某个loader在pitch方法中返回一个结果，那么这个过程就会跳过剩下的loader。这个关系引用两张图可以看的很清晰 实例：实现一个简单的style-loader，github仓库 css-loader会将css文件打包成字符串到js模块，我们自定义style-loader则需要通过操作dom，将这份css代码转成style标签插入到html的head中。避免循环引用问题，需要在pitch方法上执行。 my-style-loader.js: const { stringifyRequest } = require('loader-utils'); function loader(source) {}; loader.pitch = function(remainingRequest) { return ` let style = document.createElement('style'); const content = require(${stringifyRequest(this, '!!' + remainingRequest)}); style.innerHTML = content.default; document.head.appendChild(style); `; } module.exports = loader; webpack.config.js: const path = require('path'); module.exports = { //... module: { rules: [ { test: /\\.css$/, use: [ path.resolve('./src/my-style-loader.js'), 'css-loader' ] } ] }, }; ","date":"2020-07-23","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/:5:0","tags":["JavaScript","webpack"],"title":"Webpack-自定义loader","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/"},{"categories":["技术"],"content":"参考 编写一个loader 揭秘webpack loader ","date":"2020-07-23","objectID":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/:6:0","tags":["JavaScript","webpack"],"title":"Webpack-自定义loader","uri":"/webpack-%E8%87%AA%E5%AE%9A%E4%B9%89loader/"},{"categories":["生活"],"content":" 2019年底看到马伯庸的阅读书单上有《汴京之围》这本书，所以就安排进了我的书架，在书架上躺了半年，自身对宋史没什么兴趣，加上阅读靖康之耻这类话题，总是得好好调整一下自己的心理，最近终于找时间把这本书通读了一遍。 全书聚焦于北宋末年靖康之难的历史细节，以新闻视角叙述了北宋三年时间由盛世到亡国的经过，比较细致地描绘了宋金之间政治、军事、外交的一系列行动。与各朝代末年各种体制问题导致的积重难返不同，荒唐的徽、钦二帝与北宋士大夫集团生生造成了这场连侵略者都意想不到的人祸。 很多人对「靖康之耻」的认识基本停留在金庸先生的武侠小说或者岳飞的「靖康耻，犹未雪，臣子恨，何时灭」，想要详细了解这段历史的还是值得读一读这本书，感受一下民族几千年历史中最耻辱的事件所带来的压抑感。虽然已经知道了历史结果，但跟随着作者叙述过程的视角，总还是希望在这过程中，懦弱的士大夫集团能做对哪怕一个决策，让百姓能躲过1126年汴梁那个寒冷的冬天。(私以为有些部分作者对金人入侵行为有些轻描淡写) 最后，附上作者在书的后记中提到的写作目的。能战方能和，所谓的盛世之下，还需权衡好战与忘战的分寸，以史为鉴，居安思危 为什么要写《汴京之围》？ 当我写作《中央帝国的军事密码》时，强调的是军事地理对于战略的重要性。但在写作过程中，却有一个时代让我如鲠在喉，这个时代就是北宋末期的靖康时期。这个时代的战争已经超越了军事本身，变成了政治、经济、外交的大拼盘。在《中央帝国的军事密码》一本书中，不可能将如此丰富的内容展现，于是我将它单独抽出来，写一本专著，来剖析这个时代。 另外，靖康时期那段历史对于现代也有着不同寻常的意义。 设想回到北宋——三年前，整个社会铺天盖地在宣扬一场盛世，人们普遍相信这是一个伟大的时代，国力富强，经济繁荣；但三年后国家却灭亡了。从盛世到灭亡只用三年，这一时代境况让我有一种去一探究竟的冲动。 它提醒我们居安思危，在任何时候，危机和盛世只差一步而已。和平并不是一种必然，它要求我们怀着谦卑的心态去看待世界，学习世界所长的同时，避免自大与狂傲。更重要的是，必须有意识地避免战争，谦卑不是错，错判了形势才是最可怕的，因为任何形势都是环环相扣，一旦迈出了第一步，不仅无法回头，而且也无法把握未来的方向了。 由于研究战争和财政，我也知道战争对于中国社会的破坏性。一旦战争出现，引起的财政失衡很可能会导致整个社会的分崩离析。如今，中国的民族自尊心正处于一个爆发的阶段，在这个阶段，更需要我们随时警醒。 ","date":"2020-06-24","objectID":"/%E6%B1%B4%E4%BA%AC%E4%B9%8B%E5%9B%B4/:0:0","tags":["阅读"],"title":"📖汴京之围","uri":"/%E6%B1%B4%E4%BA%AC%E4%B9%8B%E5%9B%B4/"},{"categories":["技术"],"content":"leetcode","date":"2020-06-10","objectID":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/","tags":["算法"],"title":"学点算法","uri":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/"},{"categories":["技术"],"content":"一些数据结构与算法相关的练习，详见github仓库 ","date":"2020-06-10","objectID":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/:0:0","tags":["算法"],"title":"学点算法","uri":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/"},{"categories":["技术"],"content":"基础 ","date":"2020-06-10","objectID":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/:1:0","tags":["算法"],"title":"学点算法","uri":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/"},{"categories":["技术"],"content":"简单 两数之和 两数相加 斐波那契数列 字符串最长子串 ","date":"2020-06-10","objectID":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/:2:0","tags":["算法"],"title":"学点算法","uri":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/"},{"categories":["技术"],"content":"中等 ","date":"2020-06-10","objectID":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/:3:0","tags":["算法"],"title":"学点算法","uri":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/"},{"categories":["技术"],"content":"困难","date":"2020-06-10","objectID":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/:4:0","tags":["算法"],"title":"学点算法","uri":"/%E5%AD%A6%E7%82%B9%E7%AE%97%E6%B3%95/"},{"categories":["生活"],"content":" 人生如逆旅，我亦是行人 最近比较忙碌，除了工作还有家中发生的一些事情。今天闲下来翻了翻旧视频，看到了一段大学时候剪的视频很有趣，看了眼时间，还是2012年，感慨时间真是猝不及防的东西，较真计算起来，可能就是虚度了十分之一的生命吧。 如今也已在社会上经历了5年的毒打，大学到现在，有过特立独行的日子，也有过对未来充满希望，化身奋斗B的一阵，丧过，佛过。基本上经历了从不知所谓，到明白自己不喜欢什么，再到明白自己喜欢什么，过于丧与过于拼之间认清并且大方承认了自己能力的边界，知道自己能干什么。虽然在普世价值观中还没交出什么成绩，但至少自己活得越来越明白了。 认识了生活的真相，依然热爱着生活，我们年轻这一代人还挺好的~ 🚬 ","date":"2020-05-31","objectID":"/2020-05-31/:0:0","tags":["生活"],"title":"2020-05-31","uri":"/2020-05-31/"},{"categories":["技术"],"content":"前不久将博客从hexo转到了hugo，之前的文章简单介绍了hugo的基本使用，这一阶段我发布新文章的流程是这样的： 生成新文章，hugo new posts/xxxx.md 编辑文章内容 提交到github，git add, git commit 编译及部署，执行快速部署脚本./deploy.sh，将内容部署到github pages 虽然已经使用脚本简化了编译部署流程，但还是抱着偷懒的想法，将它接入CI/CD工具，只要专注于博客仓库本身的更新，编译及部署这些事交给工具去做🚀。所以理想的流程应该是这样： 生成新文章 编辑文章内容 提交到代码仓库 然后等待工具做完剩余事情就行了，我们自己团队工作流中目前使用jenkins比较多，但这种个人的github项目，有Github Actions这么好用的工具自然是要利用起来。 ","date":"2020-05-18","objectID":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/:0:0","tags":["工具"],"title":"使用Gitub Actions部署Hugo博客","uri":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"要做什么 回顾一下之前的构建部署流程： 项目下执行hugo编译网站，结果在./public路径 将./public设置为子模块，每次编译更新，提交到Github Pages的仓库JiangBao/jiangbao.github.io 之前的脚本deploy.sh做的也是这些事，这次要处理的就是将这个流程整理到Github Actions。 ","date":"2020-05-18","objectID":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/:1:0","tags":["工具"],"title":"使用Gitub Actions部署Hugo博客","uri":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"工作流程 其中使用到的actions模块： 获取分支代码：actions/checkout@v2 安装Hugo环境：peaceiris/actions-hugo@v2 编译：执行hugo --minify 部署到Github Pages：peaceiris/actions-gh-pages@v3 ","date":"2020-05-18","objectID":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/:2:0","tags":["工具"],"title":"使用Gitub Actions部署Hugo博客","uri":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"注意事项 因为博客代码仓库与Github Pages仓库属于两个不同的仓库，所以在获取和推送代码时会遇到权限问题，所以在这还需要做的事情是： 产生一组ssh公私钥🔑，参考 将私钥配置在博客代码仓库的Setting-\u003eSecrets 将公钥配置在Github Pages所在仓库的Deploy Keys，并勾选Allow write access 使用peaceiris/actions-gh-pages@v3action模块的deploy_key方式，参考 ","date":"2020-05-18","objectID":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/:3:0","tags":["工具"],"title":"使用Gitub Actions部署Hugo博客","uri":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"完整的workflow name:BuildandDeployon:push:branches:- masterjobs:build_deploy:runs-on:ubuntu-lateststeps:- name:Checkoutuses:actions/checkout@v2with:submodules:true- name:Setuphugouses:peaceiris/actions-hugo@v2with:hugo-version:'0.70.0'extended:true- name:Buildrun:hugo--minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{secrets.ACTIONS_DEPLOY_KEY}}external_repository:JiangBao/jiangbao.github.iopublish_dir:./publicpublish_branch:master ","date":"2020-05-18","objectID":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/:4:0","tags":["工具"],"title":"使用Gitub Actions部署Hugo博客","uri":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"参考 https://jimytc.com/posts/2020/02/16/setup_with_github_action/ ","date":"2020-05-18","objectID":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/:5:0","tags":["工具"],"title":"使用Gitub Actions部署Hugo博客","uri":"/%E4%BD%BF%E7%94%A8gitubactions%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"Deno 1.0","date":"2020-05-14","objectID":"/deno1.0/","tags":["Deno"],"title":"Deno1.0","uri":"/deno1.0/"},{"categories":["技术"],"content":" 虽然之前了解Node.js原作者Ry针对Node存在的问题，一直在折腾Deno，但只简单看过前期版本，也不知道到底什么进度。今天看到Deno发布了v1.0正式版本，来简单入门一下，等待后续跟进🦕 ","date":"2020-05-14","objectID":"/deno1.0/:0:0","tags":["Deno"],"title":"Deno1.0","uri":"/deno1.0/"},{"categories":["技术"],"content":"安装 shell安装 curl -fsSL https://deno.land/x/install/install.sh | sh Homebrew brew install deno 更多安装方式参考 ","date":"2020-05-14","objectID":"/deno1.0/:1:0","tags":["Deno"],"title":"Deno1.0","uri":"/deno1.0/"},{"categories":["技术"],"content":"开始 运行一个简单的远端程序 $ deno run https://deno.land/std/examples/welcome.ts Welcome to Deno 🦕 hello world的web服务器: 直接添加远程HTTP服务器模块依赖，无需任何本地配置 编写hello-deno.js文件，内容如下： import { serve } from \"https://deno.land/std@0.50.0/http/server.ts\"; for await (const req of serve({ port: 8000 })) { req.respond({ body: \"Hello Deno\\n\" }); } 执行deno run --allow-net hello-deno.js，即可在本地8000端口预览效果 ","date":"2020-05-14","objectID":"/deno1.0/:2:0","tags":["Deno"],"title":"Deno1.0","uri":"/deno1.0/"},{"categories":["技术"],"content":"标准库 API文档 标准模块 第三方模块 ","date":"2020-05-14","objectID":"/deno1.0/:3:0","tags":["Deno"],"title":"Deno1.0","uri":"/deno1.0/"},{"categories":["技术"],"content":"想法 对ES新特性，Promise和模块有更好的支持；安全沙箱机制 看起来极具Golang风格，依赖去中心化，终于是丢开了沉重的node_modules，可是依赖管理如何进一步优化？之前使用Golang做企业级开发总觉得包管理的方式实在粗糙 强硬地与Node.js区分开了，目前对Node包是不支持的。 我还需要更深入学习到底解决了哪些痛点问题，目前个人感觉替代原先的Node.js还是比较困难的，Node.js目前在大前端领域分量太重了，不过后面会持续关注，等待成熟。当初Node.js也是想让JS进入后端领域，结果导致了前端生态的繁荣，不知道Deno成熟起来又会在哪发光发热😕，结合作者的个人经历，难道前端玩转AI指日可待？ 对比一下Node.js与Deno的官方描述 Node: Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Deno: A secure runtime for JavaScript and TypeScript. 比较直观说明会对TypeScript有更友好的开箱即用支持，这应该属于历史必然原因，这两年TS如此火热，解决了不少脚本小子被诟病的痛点问题。 但看发布文章的描述，目前Deno内部使用微软的TypeScript编译器检查类型、生成JS的速度非常慢，需要性能上的提升还得将TSC移植到Rust。而这又将是个时间漫长的坑 ","date":"2020-05-14","objectID":"/deno1.0/:4:0","tags":["Deno"],"title":"Deno1.0","uri":"/deno1.0/"},{"categories":["技术"],"content":"Github Actions","date":"2020-05-03","objectID":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/","tags":["工具"],"title":"使用Github Actions做持续集成","uri":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"categories":["技术"],"content":"之前团队代码托管在Gitee，自动化流程是git仓库webhook+jenkins那一套。最近部分业务迁移到github，折腾一下，使用Github Actions做自动化流程。因为自己以前在Github代码使用的是Travis CI，所以这次简单记录一下Github Actions的使用。 ","date":"2020-05-03","objectID":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/:0:0","tags":["工具"],"title":"使用Github Actions做持续集成","uri":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"categories":["技术"],"content":"了解 Github将持续集成过程中：获取分支代码、测试、构建、发布到远程服务器…等等操作定义为Actions。 在项目根目录.github/workflows/文件夹下编写*.yml后缀的YAML类型文件，可以使用actions库中官方或第三方的库来快速实现获取分支代码、发布到远程服务器等操作，以此组合各类actions。 Github仓库发现.github/workflows/目录下有*.yml就会自动执行，由此实现自动化流程。 ","date":"2020-05-03","objectID":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/:1:0","tags":["工具"],"title":"使用Github Actions做持续集成","uri":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"categories":["技术"],"content":"概念 主要理解以下概念，更多的配置参考官方文档 on: 定义workflow何时被触发执行 push到master分支时 on:push:branches:- master PR到master分支时 on:pull_request:branches:- master 每小时触发执行 on:schedule:- cron:\"0 * * * *\" jobs: 要执行的多项任务 jobs:first_job:# 指定虚拟机环境(必须)runs-on:ubuntu-latest# 步骤steps:# 使用官方actions库获取分支代码- name:Checkoutuses:actions/checkout@v2# 执行命令行指令，安装依赖- name:Installdependenciesrun:npminstallsecond_job:# 另一个任务 ","date":"2020-05-03","objectID":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/:2:0","tags":["工具"],"title":"使用Github Actions做持续集成","uri":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"categories":["技术"],"content":"例子 需求：将一个create-react-app生成的典型react工程接入Github Actions，实现自动化构建、部署 ","date":"2020-05-03","objectID":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/:3:0","tags":["工具"],"title":"使用Github Actions做持续集成","uri":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"categories":["技术"],"content":"准备 整个过程可以分为: 获取分支代码-\u003e设置npm版本-\u003e安装依赖-\u003e构建-\u003e部署到远程服务器 部署文件到远程服务器 这一步涉及服务器权限认证，我们采用ssh登录，使用easingthemes/ssh-deploy第三方库。会使用到ssh私钥、服务器登录用户名、服务器地址三个参数，将这三个参数配置到代码仓库-\u003eSettings-\u003eSecrets，使之私密不可见 对于没有SSH秘钥生成经验的可以参考 执行ssh-keygen -t rsa -f \u003cYOUR_NAME\u003e，然后一路回车，可以在~/.ssh目录下看到生成了两个文件：YOUR_NAME(私钥)和YOUR_NAME.pub(公钥)。私钥是个人登录凭证，需保密；公钥要配置到部署的目标服务器 将公钥YOUR_NAME.pub内容复制到目标服务器的~/.ssh/authorized_keys中，使目标服务器允许这个秘钥对登录 将私钥文件YOUR_NAME配置到代码仓库Secrets中 ","date":"2020-05-03","objectID":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/:3:1","tags":["工具"],"title":"使用Github Actions做持续集成","uri":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"categories":["技术"],"content":"编写 项目根目录下新建./github/workflows/deploy.yml文件 name:CIon:push:# 推送到master分支时触发branches:- masterjobs:build_deploy:runs-on:ubuntu-lateststeps:# 获取分支代码- name:Checkoutuses:actions/checkout@master# 设置node版本- name:Setupnodeuses:actions/setup-node@v1with:node-version:\"12.16.1\"# 安装依赖- name:InstallDependenciesrun:npminstall# 构建- name:Buildrun:npmrunbuild# 部署到远程服务器- name:Deploytoserveruses:easingthemes/ssh-deploy@v2.0.7env:SSH_PRIVATE_KEY:${{secrets.DEPLOY_TOKEN}}#部署秘钥ARGS:\"-rltgoDzvO --delete\"#执行参数，参考库文档SOURCE:\"./build/*\"#要推送的文件REMOTE_HOST:${{secrets.SSH_HOST}}#服务器地址REMOTE_USER:${{secrets.SSH_USER}}#登录用户名TARGET:\"/your/target/dir\"#推送到目标服务器的路径 将更新提交到仓库master分支，点开actions可以看到类似下面的构建过程，至此一个简单的自动化流程就完成了，关于Github Actions还有更多可玩性值得去探索。 ","date":"2020-05-03","objectID":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/:3:2","tags":["工具"],"title":"使用Github Actions做持续集成","uri":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"categories":["技术"],"content":"参考 http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html https://frostming.com/2020/04-26/github-actions-deploy ","date":"2020-05-03","objectID":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/:4:0","tags":["工具"],"title":"使用Github Actions做持续集成","uri":"/%E4%BD%BF%E7%94%A8githubactions%E5%81%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"categories":["问题归档"],"content":"微信小程序在IOS下使用new Date()的时间格式问题","date":"2020-04-26","objectID":"/%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9C%A8ios%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/","tags":["JavaScript"],"title":"一个微信小程序在IOS下的时间格式问题","uri":"/%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9C%A8ios%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/"},{"categories":["问题归档"],"content":"背景： 最近使用uni-app开发了一个微信小程序，其中封装了picker组件做了个日期-时间选择器，在开发者工具和安卓设备下工作都正常，但是在iPhone真机下调试发现工作不生效。 机制： 自定义组件封装了picker子组件，主要监听picker组件的change事件，向顶层传递变化后的时间，其中格式化时间戳的时候，使用了Date.parse('yyyy-MM-dd hh:mm:ss')的方法。调试发现，各平台下，组件间数据传递都没有问题，但是在iPhone真机下，格式化时间会出现Invalid Date的错误。 问题： safari浏览器使用new Date()解析日期时，不支持yyyy-MM-dd 或 yyyy.MM.dd这样的格式，参考Stack Overflow上这个问题。但是yyyy/MM/dd这样的格式是chrome和safari都支持的，所以将原先时间字符串格式化为yyyy/MM/dd的格式即可解决问题。 解决： Date.parse('yyyy-MM-dd hh:mm:ss'.replace(/-/g, '/')) ","date":"2020-04-26","objectID":"/%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9C%A8ios%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/:0:0","tags":["JavaScript"],"title":"一个微信小程序在IOS下的时间格式问题","uri":"/%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9C%A8ios%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E9%97%AE%E9%A2%98/"},{"categories":["生活"],"content":"redwing","date":"2020-04-03","objectID":"/%E6%BB%A4%E9%95%9C%E5%85%BB%E9%9D%B4/","tags":["生活"],"title":"滤镜养靴","uri":"/%E6%BB%A4%E9%95%9C%E5%85%BB%E9%9D%B4/"},{"categories":["生活"],"content":"redwing入坑两年半，好像没有很认真地去养靴，不过三双靴子也算有了自己的着用痕迹。 个人脚型原因，3141最舒适，8085最帅，9411最折磨，日常穿着3141最多 入坑照 当前买家秀 3141(2017.11~now) 9411(2018.10~now) 8085(2019.02~now) ","date":"2020-04-03","objectID":"/%E6%BB%A4%E9%95%9C%E5%85%BB%E9%9D%B4/:0:0","tags":["生活"],"title":"滤镜养靴","uri":"/%E6%BB%A4%E9%95%9C%E5%85%BB%E9%9D%B4/"},{"categories":["思考"],"content":"近期事件带来的一些思考","date":"2020-04-01","objectID":"/%E9%80%83%E7%A6%BB%E7%94%9F%E6%B4%BB%E7%9A%84%E7%BB%91%E6%9E%B6/","tags":["生活"],"title":"逃离生活的绑架","uri":"/%E9%80%83%E7%A6%BB%E7%94%9F%E6%B4%BB%E7%9A%84%E7%BB%91%E6%9E%B6/"},{"categories":["思考"],"content":"昨日在V站翻到司徒正美因病离世这则消息，难以置信地去了各大网站寻找来源，最终无法确认，我希望这是一则谣言。今天陆续在各处看到有人悼念他的消息，虽然从未谋面，但有幸读过他的《JavaScript框架设计》一书，追过他的博客，对这个消息感到很难过。 自己处在互联网圈子，这样的事情也时有听闻，每次听到这种消息总是会感到很沮丧，对于大时代，一个人的离去仅如草芥，可对于他的小圈子却是天大的事。不知道什么时候起，我们这行业，甚至全社会弥漫着一种以996为荣的大跃进思想，工作以来，见了很多功利主义、房产成功学，近两年自媒体贩卖焦虑严重，主流媒体在\"指引\"我们去理解生活。 我们这批年轻人，在上一代人「特立独行」的批评声中长大，很多时代\"红利\"没赶上，现在也到了被生活绑架的年纪，日复一日，干着自己都觉得毫无意义的工作，时代在大跨步前进，GDP高歌猛进，老百姓安居乐业，我们自己却常常报复性熬到深夜，思考究竟『钢筋水泥』和『科学技术』哪个才是第一生产力？房子和车子是不是我们的最终归宿？ 希望正在经历996或者更甚的我们能停下来思考我们豁出去的意义，希望我们都能逃离生活的绑架，追求的比生存更远一些。 ","date":"2020-04-01","objectID":"/%E9%80%83%E7%A6%BB%E7%94%9F%E6%B4%BB%E7%9A%84%E7%BB%91%E6%9E%B6/:0:0","tags":["生活"],"title":"逃离生活的绑架","uri":"/%E9%80%83%E7%A6%BB%E7%94%9F%E6%B4%BB%E7%9A%84%E7%BB%91%E6%9E%B6/"},{"categories":["技术"],"content":" Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. Hugo是一个基于Go语言开发的静态网站生成器，主打简单、易用、高效、易扩展、快速部署，丰富的主题也使得Hugo也在个人博客站点搭建方面也使用广泛。之前自己的静态博客使用Hexo搭建，Hexo是一个比较广泛使用的博客框架了，但总感觉速度有些慢，最近折腾着迁移到Hugo，安装、构建、部署整个流程都感觉到了对比Hexo速度的提升🚀，简单记录一下。 ","date":"2020-03-29","objectID":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/:0:0","tags":["工具"],"title":"从Hexo转到Hugo","uri":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/"},{"categories":["技术"],"content":"1 安装 本地macOS平台直接使用Homebrew安装 brew install hugo ","date":"2020-03-29","objectID":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/:1:0","tags":["工具"],"title":"从Hexo转到Hugo","uri":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/"},{"categories":["技术"],"content":"2 创建新站点 hugo new site blog cd blog hugo new posts/first-post.md 这个时候就已经创建了新的博客站点blog，并且创建了第一篇文章first-post.md，新建的文章位于/blog/content/posts目录下。 新建文章注意 默认情况下，所有文章新建都为草稿，草稿文章是不渲染的，需要修改头部draft: true为draft: false ","date":"2020-03-29","objectID":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/:2:0","tags":["工具"],"title":"从Hexo转到Hugo","uri":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/"},{"categories":["技术"],"content":"3 使用主题 Hugo提供了丰富的主题，可以在这选择喜欢的主题，并添加到刚刚新加的博客站点，以我选择的LoveIt主题为例 首先将主题添加到项目blog/themes目录，根目录下执行： git clone -b master https://github.com/dillonzq/LoveIt.git themes/LoveIt 然后在/blog/config.toml配置主题参数： baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的 Hugo 博客站点\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.1.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 这个主题功能很强大，更多详细配置及功能可以参考项目Docs ","date":"2020-03-29","objectID":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/:3:0","tags":["工具"],"title":"从Hexo转到Hugo","uri":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/"},{"categories":["技术"],"content":"4 本地展示 此时执行以下命令即可在本地http://localhost:1313/预览当前站点状态 hugo serve ","date":"2020-03-29","objectID":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/:4:0","tags":["工具"],"title":"从Hexo转到Hugo","uri":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/"},{"categories":["技术"],"content":"5 快速部署 准备好部署网站时，运行 hugo 可以快速构建网站，项目根目录下会生成public目录，其中包含博客站点所有内容和资源，直接部署在web服务器即可。 以部署到github pages为例，参考Hugo官网说明，创建public子模块，关联原先github page仓库jiangbao.github.io，将每次构建结果提交到远程仓库，可以通过自动部署脚本实现快速部署 #!/bin/sh # If a command fails then the deploy stops set -e printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master 到这一步，每次更新文章之后，需要本地手动执行deploy.sh来部署到github page、coding page等静态页面。 貌似还是可以更简单… 如果我们只需要git add . \u0026 git commit -m \"\" \u0026 git push ，其余的自动化处理，这样又可以偷点懒 要想快速实现自动部署，可以将执行放到github actions中，每次提交更新到master分支时，自动触发构建\u0026部署，之后有时间再补上 还有更多的功能等待探索中…目前一天下来Hugo使用体验很不错，后面会将个人文章陆续迁移到这，慢慢完善 ","date":"2020-03-29","objectID":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/:5:0","tags":["工具"],"title":"从Hexo转到Hugo","uri":"/%E4%BB%8Ehexo%E8%BD%AC%E5%88%B0hugo/"},{"categories":["问题归档"],"content":"今天将新购买的个人服务器数据库升级MySQL8.0，出现了本地Navicat Premium无法连接的问题。 第一反应: 是否远程连接未打开或者服务器安全组未设置，检查了远程连接设置以及服务器安全组开放端口，都正常。 连接提示错误为： MySQL said: Authentication plugin 'caching_sha2_password' cannot be loaded: dlopen(/usr/local/lib/plugin/caching_sha2_password.so, 2): image not found 最终发现是因为MySQL8之后加密规则导致的： MySQL8版本之前之前的加密规则是mysql_native_password，在MySQL8之后，加密规则是caching_sha2_password 通过还原登录密码加密规则解决此问题： \u003e mysql -u root -p mysql\u003e ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password'; mysql\u003e FLUSH PRIVILEGES; ","date":"2020-03-27","objectID":"/connection-failed/:0:0","tags":["数据库"],"title":"Connection failed","uri":"/connection-failed/"},{"categories":["生活"],"content":" 天气很好的周末，油菜花开得正盛，暖春一到，一切都显得很有生机~~ ","date":"2020-03-14","objectID":"/weekend/:0:0","tags":["生活"],"title":"Weekend","uri":"/weekend/"},{"categories":["技术"],"content":" Content-Encoding 是一个实体消息首部，用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在 Content-Type 中标示的媒体类型内容 今天有个同事对接第三方支付时，遇到一个很有趣的问题： 『对于第三方返回的支付回调信息，系统无法解析。提示错误Error: Unsupported Content-Encoding: utf-8』 第一反应是没有按第三方要求的格式提供回调接口，可一看对方需求: 业务方提供 post application/json 的回调地址 这太常用了，系统完全支持，问题肯定不在这。结合报错，然后看了下收到消息头，很有趣的是发现header中塞入了: Content-Encoding: utf-8 MDN上关于Content-Encoding的解释如引文所说，这是标识媒体编码方式的，可选指令包括： gzip compress deflate identity br 从定义也能看出，utf-8放在这里是不合适的。然后求教了一下大佬，github、stackoverflow找了一圈，确认这样做是无意义的，并且理论上就是会返回415状态。然后同事带着满满自信去找对方反馈，对方很自信地贴出了头部设置代码： se.setContentEncoding(\"utf-8\"); httpPost.addHeader(\"Content-Type\", \"application/json;encoding=utf-8\"); application/json;encoding=utf-8是什么？是想表达content-type: application/json; charset=utf-8的意思吗？ 然后因为对方服务器的稳定性，需要我们这边做处理，向渠道大佬低头… 简单说说同事最后的处理：主要问题还是koa-bodyparser中间件处理消息时，其中引用co-body库发现头部content-encoding值为utf-8自然抛出了415状态，简单贴一下代码： switch (encoding) { case 'gzip': case 'deflate': break case 'identity': return stream default: var err = new Error('Unsupported Content-Encoding: ' + encoding) err.status = 415 throw err } 看到有人在使用express时也有过类似问题，并且提过pr给底层库，但是作者回应这并不属于bug(这确实是个正经逻辑🤔)，那么有两种简单的解决办法： 修改底层依赖库代码，上面贴的头部判断部分对utf-8直接返回数据 增加全局中间件，对每一次请求去掉头部Content-Encoding参数，再丢给后面中间件解析消息 虽然不是很麻烦的改动，却是很妥协的处理。最后： ","date":"2020-02-28","objectID":"/content-encoding-utf8/:0:0","tags":["通信协议"],"title":"content-encoding: utf-8🤔","uri":"/content-encoding-utf8/"},{"categories":["技术"],"content":" 今天在接入一个SDK时，对方加密算发使用AES/ECB/PKCS5Padding，不指定iv，这边使用Node.js的后端服务器，结果遇到了加密结果与java不一致的问题，主要还是自己没仔细翻看官方文档的问题，记录一下。 刚开始使用crypto模块createCipher函数来实现加解密逻辑，由于这么使用会默认不补全填充量，所以加密结果肯定和对方不一致，后来还是再仔细看了官方文档，发现在目前LTS版本(12.16.1)中，crypto.createCipher函数已被废弃 🤯🤯🤯， 原来自己需要的是crypto.createCipheriv(algorithm, key, iv[, options])函数： Creates and returns a Cipher object, with the given algorithm, key and initialization vector (iv). 然后轻松解决加密问题，示例代码如下： const crypto = require('crypto'); /** * AES/ECB/PKCS5Padding 加密 * @param {string} data 待加密字符串 * @param {string} key 秘钥 * @return {object} */ const encrypt = (data, key) =\u003e { const iv = \"\"; const chunk = []; const cipher = crypto.createCipheriv('aes-128-ecb', key, iv); cipher.setAutoPadding(true); chunk.push(cipher.update(data, 'utf8', 'base64')); chunk.push(cipher.final('base64')); return chunk.join(''); }; /** * AES/ECB/PKCS5Padding 解密 * @param {string} data 待解密字符串base64 * @param {string} key 秘钥 * @return {object} */ const decrypt = (data, key) =\u003e { const iv = \"\"; const chunk = []; const decipher = crypto.createDecipheriv('aes-128-ecb', key, iv); decipher.setAutoPadding(true); chunk.push(decipher.update(data, 'base64', 'utf8')); chunk.push(decipher.final('utf8')); return chunk.join(''); }; 官方文档还是要常看常新啊，对于Node.js这样的版本帝，还是要经常把脑子里那点陈旧的文档更新一下，看了一下本地开发的node版本，生产环境用的v8.9.4，个人用的v10.1.0，目前最新版本已经是13.9.0，LTS版本是12.16.1。看来之前断更的「每日一个Node.js模块」系列还是有必要重新开始了。 ","date":"2020-02-25","objectID":"/%E4%BB%8A%E6%97%A5%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/:0:0","tags":["工具"],"title":"今日关于加密算法的一个问题","uri":"/%E4%BB%8A%E6%97%A5%E5%85%B3%E4%BA%8E%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/"},{"categories":["思考"],"content":" 出于各方面原因，远程办公一直是自己比较理想的工作状态，从2018年底开始，我就开始尝试全时段远程办公，目前为止将近一年半左右的时间，也算是有了一些自己的体会。 由于受疫情影响，公司从2月初开始一直处于全员远程居家办公的状态，接近一个月的远程办公，还是遇到了不少问题： 模糊了工作与生活的界限 很多人刚开始对于居家办公的态度是极其兴奋的，穿衣自由、形象自由、沙发上坐着，床上躺着办公，可是恰恰因此模糊了工作与生活的界限。然后开始发现在家办公影响因素太多，工作效率低，甚至连原先规律的饮食都没了。最终开始呼吁：早点回公司上班吧！ 2018年底刚开始居家办公的时候，我甚至感觉自己24小时都处于办公状态，出门比正常工作时还少，作息不规律，饮食不规律(由于当时是团队初创期，所以问题更加严重)，笔记本电脑成了自己最好的朋友。 没有了原先场地办公的约束，对自身和团队的自律性及工作流合理性有了更高的要求，任何原先办公中不合理的地方都会在远程办公中被放大。 信任危机 员工是不是按时上班了？打卡… 某员工肯定工作不饱和，cue他… (深夜)这有个小问题，@所有人 拉群，所有人视频会议… 这是团队近一个月来遇到的信任问题，甚至还有提出过全程视频直播工作，没有信任基础，远程办公是挺难开展的，这个就和领导魅力以及团队文化紧密相关了。不应该提倡以管为主的模式，互联网团队需要关注的是功能交付，把握好交付时间点，但这个比较理想化了。信任危机在场地办公同样存在，只不过在远程办公中愈加被放大了。 协作危机 虽然协作问题已经是项目开发中老生常谈的问题了，但少了面对面沟通这种人类最有效的交流手段，沟通协作、问题反馈显得如此困难，大家似乎一下子失去了沟通的能力。对这类项目开发中最难的「人」的问题，不敢多言什么解决方案，就目前观察到的团队现状来说：如果不能自我驱动积极主动加强沟通，寻求协作，那对项目带来的滞后性是非常可怕的，一天开再多的会议也无法解决。 对于我这样一个不喜欢聚集办公的人来说，远程办公无疑是理想状态，对于互联网这个行业来说，相信远程办公的方式在未来会持续占有更高比重，自己也做了一年多的尝试，目前自我感觉能够在保证工作效率的情况下平衡好生活与工作了。 上面提到的问题自己在尝试初期也几乎都遇到过，其实很多都只是原先场地办公存在问题的放大版而已，我不认为回到公司上班就能克服这些困难，如果只是把远程办公当成遮羞布，那便是把问题想简单了。当然每个团队都由性格各异的成员构成，性格的差异会造成这些问题，所以会有人被指责是奋斗比，有人被骂摸鱼混日子，事实是我们不能够指着某人对他说：你应该这么做…，这是对人的不尊重。 早上周会过后对团队现状的一点思考，显得牢骚了。 ","date":"2020-02-24","objectID":"/%E5%85%B3%E4%BA%8E%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC/:0:0","tags":["思考"],"title":"关于远程办公","uri":"/%E5%85%B3%E4%BA%8E%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC/"},{"categories":["生活"],"content":" 😷😷😷 真是令人难忘的一个新年开局，全国都陷入新冠病毒的恐慌之中，有记忆以来唯一的一个大伙主动窝在家中的新年，每天关注着确诊人数的变化，希望早日结束这场疫情。 🏀🏀🏀 早晨醒来第一时间照例关注疫情新闻，结果满屏科比去世的消息，恍惚了很久。科比退役快4年了，学生时代是科比的铁粉，现在自己也早过了疯狂追球星的年纪，很难简单地用悲伤一词来描述自己的感受，就是感觉失去了青春年代的一部分，怅然若失的感觉。他13岁的二女儿Gigi也随着一起离开了，看了眼身边6个月龄的女儿，暗暗告诉自己一声：珍惜眼前人… ","date":"2020-01-27","objectID":"/%E7%B3%9F%E7%B3%95%E7%9A%842020%E5%B9%B4%E5%BC%80%E5%B1%80/:0:0","tags":["生活"],"title":"糟糕的2020年开局😷","uri":"/%E7%B3%9F%E7%B3%95%E7%9A%842020%E5%B9%B4%E5%BC%80%E5%B1%80/"},{"categories":["生活"],"content":"2020年的第一天，找时间调整自己个人博客的托管服务，更新一下博客图片的图床。 原先这个博客用Hexo搭建，部署到Github Pages，站点部署在jiangbao.github.io(Hexo+NexT主题的博客已经见了很多，看来挺受欢迎，前端的同学应该很熟悉)，博客的图片使用PicGo+Github做图床。 最近受Github影响，博客页龟速加载实在让人难受，所以还是决定把页面托管一份到国内平台，正好之前个人阿里云的服务到期了，在阿里云续费和腾讯云首次优惠之间，贫穷使我选择了将个人业务迁移到腾讯云(实在折腾🙄)，正好来一整套腾讯云产品，所以最后选择了CODING。 最后选择coding pages部署站点，PicGo+腾讯云COS做图床，为了方便还将之前个人主页www.u9c8d.com映射到了coding页面地址。忙了一下午，新地址打开速度让整个人都轻松了。翻了一下博客仓库的首次提交还是2017年5月份，快三年了，折腾了几次修改、调整，还是没有好好记录下东西，实在惭愧。 =============2020-10-29更新============= 由于coding个人、企业版入口混乱，之前改版还导致丢了一些代码，pages服务不稳定的问题，于是又转向另一个国内代码平台gitee，将静态页面放到gitee pages。因为之前使用了github actions来做项目的自动化服务，所以只需要在原项目workflows/deploy.yaml添加自动化流程即可，整体思路比较简单： gitee下新建同名空项目，例如我个人用户名jiangbao1123，新建同名项目，开启gitee pages后即可在http://jiangbao1123.gitee.io访问到页面，参考 代码提交到github仓库时同步一份到gitee仓库，可以使用wearerequired/git-mirror-action 如果使用的是gitee pages pro(付费)，则在代码同步后会自动使用hugo生成静态文件，刷新页面。如果不想使用付费服务，可以参考Gitee Pages Action实现自动部署。 关于个人的域名：由于在各平台，自己首选的名称都是『酱鲍』、『jiangbao』之类，但可惜此域名已被使用，所以自己选了『鲍』的Unicode编码 \\u9c8d，虽然识别度不够，但胜在够便宜🤔，够自己折腾了。 ","date":"2020-01-01","objectID":"/%E8%B0%83%E6%95%B4%E4%B8%80%E4%B8%8B%E5%8D%9A%E5%AE%A2%E6%89%98%E7%AE%A1/:0:0","tags":["生活"],"title":"调整一下博客托管","uri":"/%E8%B0%83%E6%95%B4%E4%B8%80%E4%B8%8B%E5%8D%9A%E5%AE%A2%E6%89%98%E7%AE%A1/"},{"categories":["生活"],"content":"2019年就要过去了，照例给自己来个年终总结。 今年听得最多的一个词就是『难』，各行各业都是叫苦声一片，听到的都是倒闭、裁员的消息。经济周期理论对经济危机预测了很久，经济危机似乎还没有到来，又或者我们已身在危机之中。这个冬天老家的天气倒是挺暖和的。 几件重要的事： 2019年，家庭迎来了新生命，闺女此刻正在边上安静睡着，上半年在工作的同时也在照顾怀孕的孩子她妈，总算在年中迎来了新生命，这真是今年对我最重要的事情了，有了孩子之后感觉自己的心态、责任感都经历了一次重塑。 这一年也送别了家庭老成员，爷爷因病离开了。一个月内紧接着面对生命的来往，使得自己在很长一段时间都没走出对死亡的恐惧。生活和工作上都是易丧、易怒，消沉了挺长一段时间，后来尝试再精简了自己本就不广的朋友圈，珍惜每次和朋友的见面、告别。 一整年都在家远程办公参与创业，目前公司还活着，题图是自己做的公司今年流水统计，可以看到经历了很多挫折波动，但整体在前行。去年在年终总结时给自己的2019规划定了一个主题：走出舒适区。当时觉得自己那个年纪过得太安逸了，然后今年尝试走出舒适区，去创业，坚持在家远程办公，也陪伴闺女到了现在6个月龄。 公司产品从无到有，从小到大，从刚开始5个人到目前20人左右的规模，这也算是今年比较有成就感的一件事了。自己的产品思维在今年也得到了提升，不再纠结于技术优劣之争，而是结合公司成员和产品实际情况，规划最具效率的生产力工具。今年主要做了服务器开发，也写了公司的小程序，自己的技术沉淀少了，业余主要是琢磨了容器技术，目前尝试结合实践，规划团队的DEVOPS流程。 身体垮了，长期在家办公，缺乏锻炼，上半年产品不稳定的时候经常是从早到深夜一直工作，身体素质直线下滑，一周前身体感觉很不舒服，想来也有近两年没体检了，去医院做了个体检，大毛病没有，小毛病一堆，躺在医院床上等待检查的时候才后悔没有好好锻炼身体。 其它一些关于2019的记忆：996，251，世界杯男篮大跌眼镜，废青，猪肉，我和我的祖国……暂时能想到就这些吧。 今年自己在技术上的沉淀比较少，创业真的是比996辛苦多的一件事，今年主要的时间也是扑在业务以及推动团队协作上。业余时间今年主要是golang和容器，k8s，再重新去研究了shell编程，似乎没其它动向了，历史、经济类书籍看了一堆，收获了一点多愁善感，也没啥产出；西瓜书断断续续翻了几章，还没入门已经停了；procreate临摹了十几幅，自己提笔依然毫无灵感。没去看过一场电影，停了微博，偶尔逛逛B站，V站，一度非常恐惧社交:(。虽然年初重新整理了个人博客，但今年真没好好记录自己的生活。立个flag：明年会好好沉淀一下自己，多产出几篇文章。 2019年，杭州的楼市似乎还一片火热的样子，不过房子依旧与我无关，自己整体情绪是向下的，以前认为自己是『佛系人生玩家』，可是有了孩子之后，开始觉得漂泊是一件羞耻的事情，所以「在杭州定居」这一条也摆在了自己2020年规划的第一位。 2020年就要来了，按照习惯，又给自己列了一个详细的个人规划，新的一年，收拾好自己的情绪，加强行动力，锻炼身体，认真生活，静下心来好好沉淀自己。 ","date":"2019-12-30","objectID":"/%E6%88%91%E7%9A%842019%E5%B9%B4/:0:0","tags":["生活"],"title":"我的2019年","uri":"/%E6%88%91%E7%9A%842019%E5%B9%B4/"},{"categories":["技术"],"content":"最近接手的一个业务，历史遗留下关于连续登录天数功能的bug，历史代码有一项判断是否连续登录天数的逻辑，正好复习一下JS关于时间的操作。 在之前自己使用过moment库实现过类似功能： function isContinuous(localTime) { let yesterday = moment().subtract(1, 'days').startOf('day'); return moment(localTime).isSame(yesterday, 'd') } 这次接手的代码使用原生JS实现，比较记录的两个时间的连续性，类似： function isContinuous(prevLocalTime, nextLocalTime) { let prevDate = new Date(prevLocalTime); let nextDate = new Date(nextLocalTime); nextDate.setDate(nextDate.getDate() - 1); return prevDate.getTime() === nextDate.getTime(); } 测试发现，入参处：前一次登录时间prevLocalTime保存为YYYY-MM-DD的格式，但是作为比较的下次登录时间使用new Date().toLocaleDateString()获取时间日期字符串，所以又是JS比较坑人的时间字符串环节。 首先看看toLocaleDateString方法获取的入参问题： toLocaleDateString()方法返回该日期对象日期部分的字符串，该字符串格式因不同语言而不同。新增的参数locales和options使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现（behavior）。在旧版本浏览器中，locales和options参数被忽略，使用的语言环境和返回的字符串格式是各自独立实现的。 from: MDN 所以这个方法获取时间日期字符串最大的问题是不同环境下得到的结果是不同的，当获取到YYYY/MM/DD这样的格式，不用于记录中保存的YYYY-MM-DD格式，使用Date对象时，在ES5标准下，没有提供时区的ISO 8601标准字符串都会被默认为标准时区，简而言之，YYYY-MM-DD和YYYY/MM/DD使用Date对象生成的时间字符串是不同的。 结论：由于toLocaleDateString方法的不可靠性，需要注意获取参数与记录参数保持一致性，此外，仅针对这段判断代码，因为比较前只做了日期的同步，根据Date对象导致的问题，可以额外针对 时、分、秒、毫秒单位进行同步，也可以解决 function isContinuous(prevLocalTime, nextLocalTime) { let prevDate = new Date(prevLocalTime); let nextDate = new Date(nextLocalTime); nextDate.setDate(nextDate.getDate() - 1); prevDate.setHours(0); prevDate.setMinutes(0); prevDate.setSeconds(0); prevDate.setMilliseconds(0); nextDate.setHours(0); nextDate.setMinutes(0); nextDate.setSeconds(0); nextDate.setMilliseconds(0); return prevDate.getTime() === nextDate.getTime(); } ","date":"2019-11-23","objectID":"/%E4%B8%80%E6%AC%A1js%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%92%E6%9F%A5/:0:0","tags":["JavaScript"],"title":"一次JS连续时间判断问题的排查","uri":"/%E4%B8%80%E6%AC%A1js%E8%BF%9E%E7%BB%AD%E6%97%B6%E9%97%B4%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%92%E6%9F%A5/"},{"categories":["思考"],"content":" 最近为了解决公司的技术挖坑问题又是拼命熬夜，每一次偿还技术债务的时候总是心里默念傻~。 创业到现在快一年了，用户量和产品流水都在良好增长，总体而言业务是在良性发展的，但随之而来的是技术得面对历史遗留问题。其实一年时间来说代码💩山还没堆得那么厉害，但是产品初期盲目的追求开发速度还是导致了很多不合适(瞎搞)的设计，随着产品推广和用户质量提高，技术发现维护成本越来越高，甚至已经不能满足当前产品需求。 作为技术，自己在创业初期总是追求着技术上细节，要做完整测试，要有详细的结构设计，各种代码规范…但与产品的博弈中总是败下阵来，作为创业团队，在目前游戏市场下，我们面临很大的生存压力，总是希望快速出原型，快速将产品推向市场，所以开发速度倒逐渐成了团队的第一追求。敏捷开发就光明正大成了不规范开发的遮羞布，经常是在快速推进功能开发和解决现网问题之间疲于奔命。终于还是接受不了这样的工作状态，喊停了开发，着手重构偿还技术债务。 其实团队最初就并非技术主导型的，自己也潜移默化地接受了更多的产品思维，不再像之前那种痴迷语言、技术优劣之争，更多地能接受技术为工具，以实现功能优先的思想，但在这二者之间的权衡目前还做得不好，甚至有点迷失。 自我反思还是技能储备还不够，许多场景无法快速给出最优方案，面对创业的生存压力，总想着快速跑起来，却失去了技术最应该做的沉淀。希望接下来保持耐心，沉淀下来，培养自己更成熟的技术能力。 ","date":"2019-09-04","objectID":"/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E5%80%BA%E5%8A%A1/:0:0","tags":["思考"],"title":"关于技术债务","uri":"/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E5%80%BA%E5%8A%A1/"},{"categories":null,"content":"宅，闷，爱好阅读、篮球 历史爱好者，野路子程序员 一个足够简单的人，还想成为一个有趣的人 邮箱： jiangbao1123@gmail.com github： https://github.com/JiangBao ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于『酱鲍』","uri":"/about/"},{"categories":["生活"],"content":" 2019-07-27 16:43:00~女~3730g ","date":"2019-07-27","objectID":"/helloworld/:0:0","tags":["生活"],"title":"Hello, World","uri":"/helloworld/"},{"categories":["问题归档"],"content":"今日在家里的笔记本下安装postgreSQL跑一个测试项目，brew一键安装，安装之后psql --version，一看轻松搞定，可是试图连接时它却这样告诉我 psql: could not connect to server: No such file or directory Is the server running locally and accepting connections on Unix domain socket \"/tmp/.s.PGSQL.5432\"? 什么？正常步骤操作怎么能报错呢？看了一下官方文档提到了这个问题： This means that the server was not started, or it was not started where createdb expected it. Again, check the installation instructions or consult the administrator. 未正常启动？怎么会犯这么低级的错误，检查发现已经正常启动，显然对我没啥帮助，stackoverflow上输入关键词mac OSX、/tmp/.s.PGSQL.5432找一找，发现遇到同样问题的还不少，大多数提到的一个方法就是删除安装地址下的postmaster.pid文件： rm -f /usr/local/var/postgres/postmaster.pid 可是我在本地路径下居然没找到这个文件，算了，再看看其它解决方法：重新启动进程、卸载干净再重装安装程序、添加PATH…一一尝试后都以失败告终，甚至一度为这答案陷入小事重启大事重装的死循环:(。 就在准备放弃的时候，尝试了这个回答的解决方案，终于成功连接，愉快接入本地postgreSQL进行测试~ ","date":"2019-04-19","objectID":"/%E5%8F%88%E8%B8%A9%E4%B8%80%E4%B8%AApostgresql%E7%9A%84%E5%9D%91/:0:0","tags":["工具"],"title":"又踩一个postgreSQL的坑","uri":"/%E5%8F%88%E8%B8%A9%E4%B8%80%E4%B8%AApostgresql%E7%9A%84%E5%9D%91/"},{"categories":["技术"],"content":"数值运算出错时，比如任何数除以0都会导致错误而终止程序运行，但是在JavaScript中不会影响程序执行，而是会返回一个特殊值–NaN(Not a Number)，表示本来要返回数值的操作数未返回数值的情况。最近在一个使用js开发的项目中，一不小心就踩到了一个关于NaN的坑。 场景大致是一个计算某个道具的价值函数，伪代码如下： // 计算配置中某个id的道具价值 const getValue = (id, num=1) =\u003e { // 假设此处配置表中id道具价值存在 const value = CONFIG[id].value; const totalValue = value * num; return totalValue; }; 道具id-数量kv值由上游提供，获取到道具价值后用于后续运算，后来在日志中发现了后续运算NaN的错误。上游传入的num参数有可能为NaN，最初认为默认赋值后即使上游传入的数量值不对也可有默认值，然后又继续愚蠢地加打印做测试： const getValue = (id, num=1) =\u003e { const value = CONFIG[id].value; const totalValue = value * num; // 在此处做了检测 if (typeof totalValue != 'number') { console.error('something error!!!'); } return totalValue; }; 果然在传入num = NaN时，默认参数赋值没生效，函数返回了NaN，并且也没有打印输出，然后试着用老办法看看： const getValue = (id, num) =\u003e { num = num || 1; const value = CONFIG[id].value; const totalValue = value * num; return totalValue; }; 这个时候，num参数在传入NaN时默认为1就可以生效，很有趣的坑，重新好好复习了一下js语法。总结一下犯的几个错误： NaN虽然是Not a Number的简写，但它依旧是numbertype的，所以typeof NaN === 'number' ES6的默认参数赋值，看一下解释，指的是：允许在没有值或者undefined被传入时使用默认形参。而NaN确实js中一个真实值，所以之前使用默认参数显然没有达到屏蔽NaN参数的作用 一切为了赶进度而放弃编写测试的习惯都是耍流氓，无论怎样，还是没做足够测试导致的问题 创业阶段，所有事情都在赶着做，自己代码缺乏足够测试，又没有专业QA功能验收，功能就被匆匆丢到线上，真是疲于应付各种线上问题了，希望自己能早点推动团队正常的开发、测试、发布流程。 ","date":"2019-01-18","objectID":"/%E8%B8%A9%E4%BA%86%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8Enan%E7%9A%84%E5%B0%8F%E5%9D%91/:0:0","tags":["JavaScript"],"title":"踩了一个关于NaN的小坑","uri":"/%E8%B8%A9%E4%BA%86%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8Enan%E7%9A%84%E5%B0%8F%E5%9D%91/"},{"categories":["生活"],"content":"为自己多申请了一天的国庆节假期，回杭州，睡了很长很长的一觉。刚刚过去的国庆假期，办完了人生中的一件大事————婚礼。比想象中还要忙，迎来又送走了一波又一波的亲戚朋友，忙碌了整个假期，只在假期尾声陪家人在县城周边逛了逛。 婚礼很普通，一如这十年走过的路，希望以后的日子，继续这样，做对寻常夫妻就好~ ","date":"2018-10-08","objectID":"/2018-10-08/:0:0","tags":["生活"],"title":"2018-10-08","uri":"/2018-10-08/"},{"categories":["生活"],"content":" 二十郎当岁，谈什么一辈子 ","date":"2018-08-10","objectID":"/%E4%BA%8C%E5%8D%81%E9%83%8E%E5%BD%93%E5%B2%81%E8%B0%88%E4%BB%80%E4%B9%88%E4%B8%80%E8%BE%88%E5%AD%90/:0:0","tags":["生活"],"title":"二十郎当岁，谈什么一辈子","uri":"/%E4%BA%8C%E5%8D%81%E9%83%8E%E5%BD%93%E5%B2%81%E8%B0%88%E4%BB%80%E4%B9%88%E4%B8%80%E8%BE%88%E5%AD%90/"},{"categories":["技术"],"content":"events是非常重要的Node.js核心模块，大多数Node.js核心API构建于惯用的异步事件驱动架构，发布/订阅模式，触发器通过触发命名事件来调用监听器，比如常见的net服务net.Server会在新连接建立时触发connection事件。 ","date":"2018-07-30","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/:0:0","tags":["Node.js"],"title":"Node.js核心模块—Events","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/"},{"categories":["技术"],"content":"简单使用 所有能触发事件的对象都是EventEmitter类的实例。 这些对象有一个eventEmitter.on()函数，用于将一个或多个函数绑定到命名事件上。事件的命名通常是驼峰式的字符串，但也可以使用任何有效的JavaScript属性键。 当EventEmitter对象触发一个事件时，所有绑定在该事件上的函数都会被同步地调用。被调用的监听器返回的任何值都将会被忽略并丢弃。 const EventEmitter = require('events'); class MyEmitter extends EventEmitter { } const myEmitter = new MyEmitter(); myEmitter.on('someEvent', () =\u003e { console.log('get someEvent!'); }); myEmitter.emit('someEvent'); ","date":"2018-07-30","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/:1:0","tags":["Node.js"],"title":"Node.js核心模块—Events","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/"},{"categories":["技术"],"content":"错误处理 当EventEmitter实例出错时，应该触发error事件，需要为error时间注册监听器，防止错误事件导致进程崩溃 myEmitter.on('error', (err) =\u003e { console.error(`something error: ${err.stack}`); }); myEmitter.emit('error', new Error('this is a error')); ","date":"2018-07-30","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/:2:0","tags":["Node.js"],"title":"Node.js核心模块—Events","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/"},{"categories":["技术"],"content":"数量限制 默认每个事件最多注册10个监听器，事件对象有EventEmitter.defaultMaxListeners属性，但修改这个值会影响所有EventEmitter实例，为了改变单个实例的限制，可以使用emitter.setMaxListeners(n)方法 ","date":"2018-07-30","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/:3:0","tags":["Node.js"],"title":"Node.js核心模块—Events","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/"},{"categories":["技术"],"content":"异步 vs 同步 EventEmitter以注册顺序同步调用所有监听器，确保事件的正确排序。可以使用setImmediate()和process.nextTick()切换到异步模式操作 const myEmitter = new MyEmitter(); // 默认同步 myEmitter.on('event', function firstListener() { console.log('第一个监听器'); }); myEmitter.on('event', function secondListener(arg1, arg2) { console.log(`第二个监听器中的事件有参数 ${arg1}、${arg2}`); }); myEmitter.on('event', function thirdListener(...args) { const parameters = args.join(', '); console.log(`第三个监听器中的事件有参数 ${parameters}`); }); myEmitter.emit('event', 1, 2, 3, 4, 5); // 异步操作 myEmitter.on('event', (a, b) =\u003e { setImmediate(() =\u003e { console.log('异步操作', a, b); }); }); myEmitter.emit('event', 'a', 'b'); ","date":"2018-07-30","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/:4:0","tags":["Node.js"],"title":"Node.js核心模块—Events","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/"},{"categories":["技术"],"content":"基于EventEmitter实现自定义任务模块 之前对于游戏服务器的任务模块，使用了基于事件的发布/订阅模式进行了重构，减少了一些逻辑耦合和回调地狱问题。 const util = require('util'); const EventEmitter = require('events'); function Mission() { EventEmitter.call(this); } util.inherits(Mission, EventEmitter); const mission = new Mission(); function handleMission(missionId, progress) { console.log(`id:${missionId}, progress is ${progress}`); } mission.on('mission1', function(progress) { handleMission('mission1', progress) }) mission.emit('mission1', 123); ","date":"2018-07-30","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/:5:0","tags":["Node.js"],"title":"Node.js核心模块—Events","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-events/"},{"categories":["技术"],"content":"JavaScript语言本身对二进制支持比较欠缺，但在处理类似TCP流或者文件流这样的流数据时，必须使用到二进制，为此，Node.js定义了Buffer类，专门处理原始内存数据。Buffer是代表原始堆分配额的数据类型，在Node.js中以类似数组的方式来使用，全局可用，不需要require。 ","date":"2018-07-13","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/:0:0","tags":["Node.js"],"title":"Node.js核心模块—Buffer","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/"},{"categories":["技术"],"content":"创建Buffer 在Node.js v6之前的版本中，使用构造函数new Buffer()的方式来创建Buffer实例，因为new Buffer()的行为会根据所传入的第一个参数的值而明显改变，所以如果应用程序没有正确地校验传入的参数、或未能正确地初始化新分配的Buffer内容，就有可能在无意中引入安全性和可靠性问题。 所以为创建更可靠、更安全的Buffer实例，v6之后，官方建议使用Buffer.from()、Buffer.alloc()和Buffer.allocUnsafe()创建Buffer实例。 // Buffer.alloc(size[, fill[, encoding]]) // 创建长度为3，且默认用0填充的Buffer const buf1 = Buffer.alloc(3); // 创建长度为3，且用1填充的Buffer const buf2 = Buffer.alloc(3, 1); // Buffer.allocUnsafe(size) // 创建一个长度为10，且未初始化的Buffer // allocUnsafe比alloc方法快 // 但返回的Buffer可能包含旧数据，因此需用fill()或write()重写 const buf3 = Buffer.allocUnsafe(10); // Buffer.from() // 创建[0x1, 0x2, 0x3]的Buffer const buf4 = Buffer.from([1, 2, 3]); ","date":"2018-07-13","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/:1:0","tags":["Node.js"],"title":"Node.js核心模块—Buffer","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/"},{"categories":["技术"],"content":"Buffer转为其它格式 Buffer.toString()方法，Node.js目前支持的字符编码包括： ‘ascii’ - 仅支持7位ASCII数据。如果设置去掉高位的话，这种编码是非常快的 ‘utf8’ - 多字节编码的Unicode字符。许多网页和其它文档格式都使用UTF-8 ‘utf16le’ - 2或4个字节，小字节序编码的Unicode字符，支持代理对（U+10000至U+10FFFF） ‘ucs2’ - utf16le的别名 ‘base64’ - Base64编码 ‘latin1’ - 一种把Buffer编码成一字节编码的字符串的方式 ‘binary’ - ‘latin1’的别名 ‘hex’ - 将每个字节编码为两个十六进制字符 ","date":"2018-07-13","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/:2:0","tags":["Node.js"],"title":"Node.js核心模块—Buffer","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/"},{"categories":["技术"],"content":"使用Buffer修改字符串编码 ","date":"2018-07-13","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/:3:0","tags":["Node.js"],"title":"Node.js核心模块—Buffer","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/"},{"categories":["技术"],"content":"创建基本验证信息的头部 const user = 'JiangBao'; const password = '123456'; const encoded = Buffer.from(`${user}:${password}`).toString('base64'); // SmlhbmdCYW86MTIzNDU2 const decoded = Buffer.from(encoded, 'base64').toString(); // JiangBao:123456 ","date":"2018-07-13","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/:3:1","tags":["Node.js"],"title":"Node.js核心模块—Buffer","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/"},{"categories":["技术"],"content":"data URIs Data URIs允许一个资源以行内编码的形式存在于web页面中，遵循以下格式： data:[MIME-type][;charset=\u003cencoding\u003e[;base64]],\u003cdata\u003e 输出data URI： const fs = require('fs'); const mime = 'image/jpeg'; const encoding = 'base64'; const data = fs.readFileSync('./icon.jpeg').toString(encoding); // data:image/jpeg;base64,/9j/2wCEAAgGBgcGBQgHBwcJCQgKDBQNDA... const uri = `data:${mime};${encoding},${data}`; 解析data URI： const fs = require('fs'); const uri = 'data:image/jpeg;base64,/9j/2wCEAAgGBgcGBQgHBwcJCQgKDBQNDA...'; const imageData = uri.split(',')[1]; const buf = Buffer.from(imageData, 'base64'); fs.writeFileSync('./icon.bak.jpeg', buf); ","date":"2018-07-13","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/:3:2","tags":["Node.js"],"title":"Node.js核心模块—Buffer","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/"},{"categories":["技术"],"content":"使用场景 ","date":"2018-07-13","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/:4:0","tags":["Node.js"],"title":"Node.js核心模块—Buffer","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/"},{"categories":["技术"],"content":"1. I/O操作 对于文件或者网络数据等操作时，可以使用流式操作 const fs = require('fs'); const inputStream = fs.createReadStream('file.txt'); const outputStream = fs.createWriteStream('output.txt'); inputStream.pipe(outputStream); ","date":"2018-07-13","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/:4:1","tags":["Node.js"],"title":"Node.js核心模块—Buffer","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/"},{"categories":["技术"],"content":"2. 压缩/解压 使用Node.js核心模块zlib实现压缩、解压功能也是基于stream构建的 ","date":"2018-07-13","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/:4:2","tags":["Node.js"],"title":"Node.js核心模块—Buffer","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-buffer/"},{"categories":["生活"],"content":"台风天气，雨天的周末~ ","date":"2018-07-12","objectID":"/%E5%91%A8%E6%9C%AB%E9%9B%A8%E5%A4%A9/:0:0","tags":["生活"],"title":"周末雨天","uri":"/%E5%91%A8%E6%9C%AB%E9%9B%A8%E5%A4%A9/"},{"categories":["技术"],"content":"crypto是Node.js核心模块之一，主要用于各类加密场景。使用C/C++实现各类加密算法，然后暴露为javascript接口，包括对OpenSSL的哈希、HMAC、加密、解密、签名以及验证功能的一整套封装。我个人使用最多的场景是各类第三方SDK接入时接口数据的签名认证，使用起来简单方便。 如果对于加密相关的安全基础知识不了解，可以查看这篇文章。 ","date":"2018-07-10","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-crypto/:0:0","tags":["Node.js"],"title":"Node.js核心模块—Crypto","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-crypto/"},{"categories":["技术"],"content":"哈希 MD5是最常用的哈希算法，但是存在一定的碰撞问题，所以可以使用sha1、sha256等，使用crypto模块进行哈希的时候，使用Hash类，主要有三个步骤： crypto.createHash(algorithm) 创建并返回hash实例，用于生成哈希摘要，algorithm用于指定算法类型，比如：md5、sha1 hash.update(data) 使用data更新哈希内容，默认UTF-8编码，流式传输时，可多次调用此方法 hash.digest(encoding='binary') 计算传入数据(调用hash.update())的摘要，按照指定encoding返回，默认是Buffer 调用此方法后，hash实例已被重置，再次调用会报错 以MD5签名为例： const crypto = require('crypto); const hash = crypto.createHash('md5'); hash.update('Hello,'); hash.update('world'); hash.digest('hex'); // 7add895cc0518859d8cc85da0ff4756b ","date":"2018-07-10","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-crypto/:1:0","tags":["Node.js"],"title":"Node.js核心模块—Crypto","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-crypto/"},{"categories":["技术"],"content":"Hmac Hmac全称keyed-Hash Message Authentication Code，Hmac也属于一种哈希算法，不过需要多一个秘钥输入，可以有效防止类似MD5的彩虹表等攻击 使用Hmac类生成实例，其它update和digest与hash对象类似 const crypto = require('crypto'); const hmac = crypto.createHmac('sha256', 'this-is-your-secret-key'); hmac.update('Hello,'); hmac.update('world'); hmac.digest('hex'); // 7054a95555e11a1721730e6b04295915b83871c6e090462fcd8c25af7d7afc77 ","date":"2018-07-10","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-crypto/:2:0","tags":["Node.js"],"title":"Node.js核心模块—Crypto","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-crypto/"},{"categories":["技术"],"content":"对称加密-AES 通信一方使用秘钥加密原始数据，接收方收到数据后，使用同一秘钥进行解密，即为对称加密。AES是我在业务中比较常用的对称加密算法 踩坑更新： crypto.createCipher方法已于v10.x版本之后废弃，必须使用crypto.createCipheriv方法。否则第三方渠道使用java做aes加密逻辑时，会造成加解密结果不一致的问题！！！ const crypto = require('crypto'); function aesEncrypt(data, key) { const cipher = crypto.createCipher('aes192', key); let crypted = cipher.update(data, 'utf8', 'hex'); crypted += cipher.final('hex'); return crypted; } function aesDecrypt(encrypted, key) { const decipher = crypto.createDecipher('aes192', key); let decrypted = decipher.update(encrypted, 'hex', 'utf8'); decrypted += decipher.final('utf8'); return decrypted; } const data = 'Hello, World!'; const key = 'Password!'; const encrypted = aesEncrypt(data, key); //98b549b7cf97859d11b814a1bff4eecb const decrypted = aesDecrypt(encrypted, key); //Hello, World! ","date":"2018-07-10","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-crypto/:3:0","tags":["Node.js"],"title":"Node.js核心模块—Crypto","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-crypto/"},{"categories":["技术"],"content":"非对称加密-RSA 非对称加密指双方使用不同的秘钥进行加密和解密，通信双方都会持有公钥和私钥，假设有两组公私钥，a-prv.pem、a-pub.pem和b-prv.pem、b-pub.pem，使用其中一把秘钥加密的密文，只能使用对应的另一把秘钥才能解密，比如，使用了a-prv.pem加密，则必须使用a-pub.pem才能解密。RSA是比较常用的非对称加密算法，主要使用几个方法： // 私钥加密 crypto.privateEncrypt(privateKey, buffer) // 公钥解密 crypto.publicDecrypt(publicKey, buffer) // 公钥加密 crypto.publicEncrypt(publicKey, buffer) // 私钥解密 crypto.privateDecrypt(privateKey, buffer) https://cnodejs.org/topic/504061d7fef591855112bab5 https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640 ","date":"2018-07-10","objectID":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-crypto/:4:0","tags":["Node.js"],"title":"Node.js核心模块—Crypto","uri":"/node.js%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97-crypto/"},{"categories":["生活"],"content":"逃离舒适区~ ","date":"2018-07-04","objectID":"/new-start/:0:0","tags":["生活"],"title":"New Start","uri":"/new-start/"},{"categories":["技术"],"content":"圣杯布局和双飞翼布局都是平时开发中比较常用的页面布局，两者核心都一样，本质上都是三栏布局，此文记录自己平时对圣杯布局的实践。 圣杯布局题图所示，传统布局要求内容部分左右两侧定宽，中间部分自适应宽度，整体主要结构包括 头部 底部 中间内容：左边、中间、右边三栏 ","date":"2017-05-20","objectID":"/css%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%AE%9E%E8%B7%B5/:0:0","tags":["css"],"title":"CSS圣杯布局实践","uri":"/css%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%AE%9E%E8%B7%B5/"},{"categories":["技术"],"content":"1. float \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003eCSS圣杯布局\u003c/title\u003e \u003cstyle\u003e * { margin: 0; padding: 0; text-align: center; } body { /* 左右定宽时，为保证页面显示，设置最小宽度 */ min-width: 600px; } .header,.footer { height: 60px; width: 100%; background-color: #F1F1F1; line-height: 60px; } .content { overflow: hidden; } .content div { height: 600px; line-height: 600px; } .middle { background-color: #DDD; } .left { float: left; width: 200px; background-color: #CCC; } .right { float: right; width: 250px; background-color: #CCC; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"header\"\u003eheader\u003c/div\u003e \u003cdiv class=\"content\"\u003e \u003cdiv class=\"left\"\u003eleft\u003c/div\u003e \u003cdiv class=\"right\"\u003eright\u003c/div\u003e \u003cdiv class=\"middle\"\u003emiddle\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"footer\"\u003efooter\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2017-05-20","objectID":"/css%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%AE%9E%E8%B7%B5/:1:0","tags":["css"],"title":"CSS圣杯布局实践","uri":"/css%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%AE%9E%E8%B7%B5/"},{"categories":["技术"],"content":"2. flex \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003eCSS圣杯布局\u003c/title\u003e \u003cstyle\u003e * { margin: 0; padding: 0; text-align: center; } .header,.footer { height: 60px; width: 100%; background-color: #F1F1F1; line-height: 60px; } .content { display: flex; } .content div { height: 600px; line-height: 600px; } .middle { flex: 1; background-color: #DDD; } .left { width: 200px; background-color: #CCC; } .right { width: 250px; background-color: #CCC; } /* 加入响应式布局 */ @media screen and (max-width: 800px) { .content { flex-flow: row wrap; } .left,.right,.middle { flex: 1 100%; } .content div { height: 100px; line-height: 100px; } } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"header\"\u003eheader\u003c/div\u003e \u003cdiv class=\"content\"\u003e \u003cdiv class=\"left\"\u003eleft\u003c/div\u003e \u003cdiv class=\"middle\"\u003emiddle\u003c/div\u003e \u003cdiv class=\"right\"\u003eright\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"footer\"\u003efooter\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2017-05-20","objectID":"/css%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%AE%9E%E8%B7%B5/:2:0","tags":["css"],"title":"CSS圣杯布局实践","uri":"/css%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%AE%9E%E8%B7%B5/"},{"categories":["技术"],"content":"水平居中 ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:1:0","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"1. 行内元素 \u003cbody\u003e \u003cdiv class=\"center-wrap\"\u003e水平居中\u003c/div\u003e \u003c/body\u003e .center-wrap { text-align: center; } ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:1:1","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"2. 确定宽度块级元素 \u003cbody\u003e \u003cdiv class=\"center-wrap\"\u003e水平居中\u003c/div\u003e \u003c/body\u003e .center-wrap { border: 1px solid; width: 600px; margin: 0 auto; } ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:1:2","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"3. 未知宽度块级元素 table display: table配合margin: 0 auto \u003cbody\u003e \u003cdiv class=\"center-wrap\"\u003e水平居中\u003c/div\u003e \u003c/body\u003e .center-wrap { border: 1px solid; display: table; margin: 0 auto; } inline-block(多个块状元素) 子元素设置display: inline-block，父元素设置text-align: center \u003cbody\u003e \u003cdiv class=\"center-wrap\"\u003e \u003cdiv class=\"child-wrap\"\u003e元素1\u003c/div\u003e \u003cdiv class=\"child-wrap\"\u003e元素2\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e .center-wrap { text-align: center; } .child-wrap { border: 1px solid; display: inline-block; } flex \u003cbody\u003e \u003cdiv class=\"center-wrap\"\u003e \u003cdiv class=\"child-wrap\"\u003e元素1\u003c/div\u003e \u003cdiv class=\"child-wrap\"\u003e元素2\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e .center-wrap { display: flex; justify-content: center; } .child-wrap { border: 1px solid; } 绝对定位+transform \u003cbody\u003e \u003cdiv class=\"center-wrap\"\u003e \u003cdiv class=\"child-wrap\"\u003e居中元素\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e .center-wrap { border: 1px solid; position: relative; width: 600px; height: 600px; } .child-wrap { border: 1px solid; position: absolute; left: 50%; transform: translate(-50%, 0); } ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:1:3","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"垂直居中 ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:2:0","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"1. 文本类 单行文本 设置padding-top=padding-bottom，利用padding撑起 line-height=height \u003cbody\u003e \u003cp class=\"vertical-center\"\u003e单行文本垂直居中\u003c/p\u003e \u003c/body\u003e .vertical-center { border: 1px solid; height: 60px; line-height: 60px; padding: 30px 0; } 多行文本 \u003cbody\u003e \u003cdiv class=\"center-wrap\"\u003e \u003cdiv class=\"text-area\"\u003e \u003cp\u003e多行垂直居中文本\u003c/p\u003e \u003cp\u003e多行垂直居中文本\u003c/p\u003e \u003cp\u003e多行垂直居中文本\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e .center-wrap { border: 1px solid; width: 600px; height: 600px; display: table; } .text-area { display: table-cell; vertical-align: middle; } ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:2:1","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"2. 块级元素 position+margin 父元素设置相对定位，子元素设置绝对定位，top、bottom设置为0，margin: auto实现自适应居中 \u003cbody\u003e \u003cdiv class=\"center-wrap\"\u003e \u003cdiv class=\"center-div\"\u003e这是垂直居中元素\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e .center-wrap { border: 1px solid; position: relative; width: 600px; height: 600px; } .center-div { border: 1px solid; position: absolute; width: 300px; height: 200px; top: 0; bottom: 0; margin: auto; } flex 两种方法，需要知道父元素高度 父元素设置display: flex; align-items: center 父元素设置display: flex; 子元素设置margin: auto实现自适应居中 \u003cdiv class=\"center-wrap\"\u003e \u003cdiv class=\"center-div\"\u003e这是垂直居中元素\u003c/div\u003e \u003c/div\u003e .center-wrap { border: 1px solid; height: 600px; display: flex; align-items: center; } .center-wrap { border: 1px solid; height: 600px; display: flex; } .center-div { border: 1px solid; margin: auto; } transform 父元素相对定位，子元素绝对定位，设置transform \u003cdiv class=\"center-wrap\"\u003e \u003cdiv class=\"center-div\"\u003e这是垂直居中元素\u003c/div\u003e \u003c/div\u003e .center-wrap { border: 1px solid; height: 600px; position: relative; } .center-div { border: 1px solid; width: 200px; height: 200px; position: absolute; top: 50%; transform: translate(0, -50%); } ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:2:2","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"水平垂直居中实践 对于以下场景，要使[class=center-div]的元素水平垂直居中，自己常用的水平垂直同时居中的方法 \u003cdiv class=\"center-wrap\"\u003e \u003cdiv class=\"center-div\"\u003e这是居中元素\u003c/div\u003e \u003c/div\u003e ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:3:0","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"flex .center-wrap { border: 1px solid; width: 600px; height: 600px; display: flex; justify-content: center; align-items: center; } .center-div { border: 1px solid; width: 200px; height: 200px; } ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:3:1","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"绝对定位+margin:auto .center-wrap { border: 1px solid; width: 600px; height: 600px; position: relative; } .center-div { border: 1px solid; width: 200px; height: 200px; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; } ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:3:2","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"绝对定位+transform .center-wrap { border: 1px solid; width: 600px; height: 600px; position: relative; } .center-div { border: 1px solid; width: 200px; height: 200px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:3:3","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"table-cell .center-wrap { border: 1px solid; width: 600px; height: 600px; display: table; } .center-div { border: 1px solid; display: table-cell; text-align: center; vertical-align: middle; } ","date":"2017-05-15","objectID":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/:3:4","tags":["css"],"title":"CSS水平垂直居中常用方式","uri":"/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["技术"],"content":"拥抱Promise","date":"2017-04-21","objectID":"/%E4%BD%BF%E7%94%A8promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/","tags":["JavaScript"],"title":"使用Promise解决回调地狱问题","uri":"/%E4%BD%BF%E7%94%A8promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/"},{"categories":["技术"],"content":"JavaScript中有许多异步的操作，原生使用回调方法来实现异步。很多时候在维护一系列异步操作的执行顺序时会形成「回调地狱」，代码难以阅读。 之前接手的一个团队内部的老项目，使用Node.js开发，用的就是error-first callback风格的代码，我和同事接手后使用的都是ES6新特性——Promise来处理异步逻辑，所以最近我对一些公共方法进行了Promise化处理，虽然使用类似bluebird这样的库很容易实现，但这么简单的需求当然选择造一下轮子。 编写promisify公共方法，对旧代码目标异步函数做Promise化处理。 show me the code: function promisify(func) { return function (...args) { return new Promise((resolve, reject) =\u003e { function callback(err, res) { if (err) { reject(err); } else { resolve(res); } } args.push(callback); f.call(this, ...args); }); }; } ","date":"2017-04-21","objectID":"/%E4%BD%BF%E7%94%A8promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/:0:0","tags":["JavaScript"],"title":"使用Promise解决回调地狱问题","uri":"/%E4%BD%BF%E7%94%A8promise%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98/"},{"categories":["技术"],"content":"JavaScript数据类型分为基础数据类型和引用数据类型，基础类型的复制直接复制给其它变量即可，但是JS本身不支持引用类型的深拷贝，所以简单记录如何实现JS的深拷贝。 目前我比较常用Object.assign和{...object}来复制对象类型数据，但是这两个方法都只是浅拷贝，举个例子，对于嵌套的对象类型： let user = { name: 'Bob', body: { weight: 60, height: 180 } }; let clone = Object.assign({}, user); clone.name = 'clone'; clone.body.height += 10; console.log(user); //{ name: 'Bob', body: { weight: 60, height: 190 } } console.log(clone); //{ name: 'clone', body: { weight: 60, height: 190 } } 可以看到，在这种情况下副本修改嵌套对象的内容，还是会影响到原来的数据。之前和同事讨论的时候，发现他们会用JSON.parse(JSON.stringify(obj))这样的方式来实现深度拷贝，但是搜了一下，这种方式对于特殊的function、正则类型无效，对于循环引用的对象数据会报错，所以局限性还是比较大。 实际工作中，一般用lodash的cloneDeep方法来处理此类场景，实现原生JS的深拷贝，就是实现一下这个方法。 Show me the code function cloneDeep(source) { if (source === null) return null; if (source instanceof RegExp) return new RegExp(source); if (source instanceof Date) return new Date(source); if (typeof source === 'Function') return new function(source) {}; if (typeof source !== 'object') return source; let clone = Array.isArray(source) ? [] : {}; for (let key in source) { clone[key] = cloneDeep(source[key]) } return clone; } ","date":"2017-03-02","objectID":"/js%E6%B7%B1%E6%8B%B7%E8%B4%9D/:0:0","tags":["JavaScript"],"title":"JS深拷贝","uri":"/js%E6%B7%B1%E6%8B%B7%E8%B4%9D/"}]